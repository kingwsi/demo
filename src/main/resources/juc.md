#### JMM java内存模型
##### 线程独享和共享内存空间
- 1.java中所有的变量都是存在主内存里的。
- 2.各自的线程在工作的时候会自己拿到一块工作内存。里面保存了该线程用到的变量的副本。
- 3.线程对变量的操作，都是对自己工作内存中变量的操作，不能操作主内存。
- 4.最终工作内存中的数据是需要同步回主内存，来完成主内存中变量的更新的。

##### JMM 线程保证安全的三个特性：
- 可见性 volatile(不保证原子性，禁止指令重排序) 一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）
- 原子性 atomic 一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。
- 有序性 synchronized

#### 线程池
##### 5种类型
- 1.固定大小线程池 - 
- 2.单线程线程池 - 
- 3.缓存线程池 - 最大长度 Interger. MAX_VALUE 小心OOM
- 4.定长线程池 - 可按固定周期执行
- 5.并行线程池 - Fork Join

##### 7个参数
- 1.核心线程数
- 2.最大线程数
- 3.空闲线程存活时间
- 4.时间单位
- 5.等待队列 线程池中线程数量超过核心线程数
- 6.线程工厂
- 7.拒绝策略
##### 拒绝策略
- 抛出异常，任务提交者可感知
- 直接丢弃，无感知
- 丢弃队列头部节点，无感知
- 将任务的执行权交予提交任务的线程来执行，谁提交谁负责
`当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到 maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了`

#### CAS
##### 是什么？
比较并交换 Compare And Swap，是Unsafe类中的 native方法，是一个CPU原子指令
`比较旧值是否相同，相同则从工作内存写入到公共内存中`