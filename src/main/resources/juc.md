#### JMM java内存模型
##### 线程独享和共享内存空间
- 1.java中所有的变量都是存在主内存里的。
- 2.各自的线程在工作的时候会自己拿到一块工作内存。里面保存了该线程用到的变量的副本。
- 3.线程对变量的操作，都是对自己工作内存中变量的操作，不能操作主内存。
- 4.最终工作内存中的数据是需要同步回主内存，来完成主内存中变量的更新的。

##### JMM 线程保证安全的三个特性：
- 可见性 volatile(不保证原子性，禁止指令重排序) 一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）
- 原子性 atomic 一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。
- 有序性 synchronized

#### 线程池
##### 5种类型
- 1.newFixedThreadPool 固定大小线程池：
- 2.newSingleThreadExecutor 单线程线程池：
- 3.newCachedThreadPool 缓存线程池：最大长度 Integer.MAX_VALUE 小心OOM
- 4.newSingleThreadScheduledExecutor 延迟单线程池：可按固定周期执行，单线程
- 5.newScheduledThreadPool 延迟线程池：可执行任务的线程池
- 6.newWorkStealingPool 抢占式线程池：没有顺序 抢占式 1.8新增

##### 7个参数
- 1.核心线程数
- 2.最大线程数
- 3.空闲线程存活时间
- 4.时间单位
- 5.等待队列 线程池中线程数量超过核心线程数
- 6.线程工厂
- 7.拒绝策略
##### 拒绝策略
- 抛出异常，任务提交者可感知
- 直接丢弃，无感知
- 丢弃队列头部节点，无感知
- 将任务的执行权交予提交任务的线程来执行，谁提交谁负责
`当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到 maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了`

#### CAS
##### 是什么？
比较并交换 Compare And Swap，是Unsafe类中的 native方法，是一个CPU原子指令
`比较旧值是否相同，相同则从工作内存写入到公共内存中`
##### 三个参数
内存值V，旧的预期值A, 要修改的值 B
当V=A时候才更新B
##### 原子引用包装类 
AtomicReference<T> 可以把我们自己的对象包装成原子对象
##### CAS缺点是什么
- 如果CAS失败，会长时间自旋给CPU带来较大开销
- 只能操作一个变量
- ABA问题
##### ABA问题 如何解决
使用带版本号的包装类 AtomicStampedReference<?>
